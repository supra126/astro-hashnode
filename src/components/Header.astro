---
import Container from './Container.astro';
import PublicationLogo from './PublicationLogo.astro';
import type { Publication } from '../types';

interface Props {
  publication: Publication;
  currentMenuId?: string | null;
}

const { publication, currentMenuId } = Astro.props;

const navItems = publication.preferences?.navbarItems ?? [];
// Always show dark mode toggle — the publication setting only controls the default theme
const hasDarkMode = true;
---

<header transition:persist class="sticky top-0 z-40 border-b border-slate-200/80 bg-white/80 backdrop-blur-lg dark:border-slate-800/80 dark:bg-neutral-950/80">
  <Container class="flex h-16 items-center justify-between">
    <!-- Logo -->
    <PublicationLogo publication={publication} size="lg" />

    <!-- Desktop Nav -->
    <nav class="hidden items-center gap-1 md:flex" aria-label="Main navigation">
      {navItems.map((item) => (
        <a
          href={item.url}
          class:list={[
            'rounded-md px-3 py-2 text-sm font-medium transition-colors hover:bg-slate-100 dark:hover:bg-slate-800',
            currentMenuId === item.id
              ? 'text-blue-600 dark:text-blue-400'
              : 'text-slate-700 dark:text-slate-300',
          ]}
        >
          {item.label}
        </a>
      ))}
    </nav>

    <!-- Right actions -->
    <div class="flex items-center gap-2">
      <!-- Search button -->
      <button
        type="button"
        id="search-btn"
        class="rounded-full p-2 text-slate-600 transition-colors hover:bg-slate-100 dark:text-slate-400 dark:hover:bg-slate-800"
        aria-label="Search"
      >
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="11" cy="11" r="8" />
          <path d="m21 21-4.3-4.3" />
        </svg>
      </button>

      <!-- Dark mode toggle -->
      {hasDarkMode && (
        <button
          type="button"
          id="theme-toggle"
          class="rounded-full p-2 text-slate-600 transition-colors hover:bg-slate-100 dark:text-slate-400 dark:hover:bg-slate-800"
          aria-label="Toggle dark mode"
        >
          <!-- Sun icon (shown in dark mode) -->
          <svg class="hidden h-5 w-5 dark:block" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="4" />
            <path d="M12 2v2" />
            <path d="M12 20v2" />
            <path d="m4.93 4.93 1.41 1.41" />
            <path d="m17.66 17.66 1.41 1.41" />
            <path d="M2 12h2" />
            <path d="M20 12h2" />
            <path d="m6.34 17.66-1.41 1.41" />
            <path d="m19.07 4.93-1.41 1.41" />
          </svg>
          <!-- Moon icon (shown in light mode) -->
          <svg class="block h-5 w-5 dark:hidden" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z" />
          </svg>
        </button>
      )}

      <!-- Mobile menu toggle -->
      <button
        type="button"
        id="mobile-menu-btn"
        class="rounded-full p-2 text-slate-600 transition-colors hover:bg-slate-100 md:hidden dark:text-slate-400 dark:hover:bg-slate-800"
        aria-label="Open menu"
        aria-expanded="false"
        aria-controls="mobile-menu"
      >
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="4" x2="20" y1="12" y2="12" />
          <line x1="4" x2="20" y1="6" y2="6" />
          <line x1="4" x2="20" y1="18" y2="18" />
        </svg>
      </button>
    </div>
  </Container>

</header>

<!-- Mobile menu overlay (outside header to avoid backdrop-filter containing block) -->
<div
  id="mobile-menu"
  class="fixed inset-0 z-50 hidden"
  role="dialog"
  aria-modal="true"
  aria-label="Navigation menu"
>
  <!-- Backdrop -->
  <div id="mobile-menu-backdrop" class="fixed inset-0 bg-black/50 backdrop-blur-sm transition-opacity duration-300 opacity-0"></div>

  <!-- Sidebar -->
  <nav class="fixed inset-y-0 right-0 w-72 overflow-y-auto bg-white p-6 shadow-xl transition-transform duration-300 translate-x-full dark:bg-slate-900">
    <div class="mb-8 flex items-center justify-between">
      <PublicationLogo publication={publication} size="sm" />
      <button
        type="button"
        id="mobile-menu-close"
        class="rounded-full p-2 text-slate-600 hover:bg-slate-100 dark:text-slate-400 dark:hover:bg-slate-800"
        aria-label="Close menu"
      >
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M18 6 6 18" />
          <path d="m6 6 12 12" />
        </svg>
      </button>
    </div>

    <ul class="space-y-1">
      {navItems.map((item) => (
        <li>
          <a
            href={item.url}
            class:list={[
              'block rounded-md px-3 py-2.5 text-sm font-medium transition-colors hover:bg-slate-100 dark:hover:bg-slate-800',
              currentMenuId === item.id
                ? 'bg-slate-100 text-blue-600 dark:bg-slate-800 dark:text-blue-400'
                : 'text-slate-700 dark:text-slate-300',
            ]}
          >
            {item.label}
          </a>
        </li>
      ))}
    </ul>
  </nav>
</div>

<!-- Header client-side scripts (dark mode toggle + mobile menu) -->
<!-- Uses event delegation on document so listeners survive View Transition swaps -->
<script>
  function openMobileMenu() {
    const menu = document.getElementById('mobile-menu');
    if (!menu) return;
    menu.classList.remove('hidden');
    // Trigger reflow so transitions apply
    menu.offsetHeight;
    menu.querySelector('#mobile-menu-backdrop')?.classList.add('opacity-100');
    menu.querySelector('nav')?.classList.remove('translate-x-full');
    document.getElementById('mobile-menu-btn')?.setAttribute('aria-expanded', 'true');
    document.body.style.overflow = 'hidden';
  }

  function closeMobileMenu() {
    const menu = document.getElementById('mobile-menu');
    if (!menu) return;
    menu.querySelector('#mobile-menu-backdrop')?.classList.remove('opacity-100');
    menu.querySelector('nav')?.classList.add('translate-x-full');
    document.getElementById('mobile-menu-btn')?.setAttribute('aria-expanded', 'false');
    document.body.style.overflow = '';
    // Wait for transition to finish before hiding
    setTimeout(() => menu.classList.add('hidden'), 300);
  }

  // --- Logo Easter Eggs ---
  // Uses capture phase to intercept BEFORE Astro's View Transition router
  let logoClickCount = 0;
  let logoClickTimer = 0;
  let logoLongPressTimer = 0;
  let logoLongPressed = false;

  // Long-press Logo (1.5s) → permanent Matrix Rain
  function onLogoPointerDown(e: PointerEvent) {
    const target = e.target as HTMLElement;
    if (!target.closest('header a[href="/"]')) return;
    logoLongPressed = false;
    logoLongPressTimer = window.setTimeout(() => {
      logoLongPressed = true;
      window.__triggerMatrixRain?.(true);
    }, 1500);
  }

  function onLogoPointerUp() {
    clearTimeout(logoLongPressTimer);
  }

  document.addEventListener('pointerdown', onLogoPointerDown, true);
  document.addEventListener('pointerup', onLogoPointerUp, true);
  document.addEventListener('pointercancel', onLogoPointerUp, true);

  // 5-click Logo → timed Matrix Rain
  document.addEventListener('click', (e) => {
    const target = e.target as HTMLElement;
    const logoLink = target.closest('header a[href="/"]');
    if (!logoLink) return;

    // Skip click event if long-press already triggered
    if (logoLongPressed) {
      e.preventDefault();
      e.stopPropagation();
      logoLongPressed = false;
      logoClickCount = 0;
      return;
    }

    logoClickCount++;
    clearTimeout(logoClickTimer);
    logoClickTimer = window.setTimeout(() => { logoClickCount = 0; }, 2000);

    if (logoClickCount >= 5) {
      e.preventDefault();
      e.stopPropagation();
      logoClickCount = 0;
      clearTimeout(logoClickTimer);
      window.__triggerMatrixRain?.();
    } else if (logoClickCount > 1 && location.pathname === '/') {
      // On home page, prevent Astro navigation on intermediate clicks (2-4)
      e.preventDefault();
      e.stopPropagation();
    }
    // Click 1: let through normally (navigates to home if on other pages)
  }, true); // capture phase — fires before Astro's router

  // Event delegation: all click handlers on document survive View Transition swaps
  document.addEventListener('click', (e) => {
    const target = e.target as HTMLElement;

    // Dark mode toggle
    if (target.closest('#theme-toggle')) {
      const isDark = document.documentElement.classList.toggle('dark');
      localStorage.setItem('theme', isDark ? 'dark' : 'light');
    }

    // Mobile menu open
    if (target.closest('#mobile-menu-btn')) {
      openMobileMenu();
    }

    // Mobile menu close (close button or backdrop)
    if (target.closest('#mobile-menu-close') || target.id === 'mobile-menu-backdrop') {
      closeMobileMenu();
    }
  });

  // --- Konami Code Easter Egg ---
  // ↑↑↓↓←→←→BA = timed rain, ↑↑↓↓←→←→BA + Enter = permanent rain
  const KONAMI = ['ArrowUp','ArrowUp','ArrowDown','ArrowDown','ArrowLeft','ArrowRight','ArrowLeft','ArrowRight','b','a'];
  let konamiIndex = 0;
  let konamiTimer = 0;
  let konamiComplete = false;
  let konamiCompleteTimer = 0;

  document.addEventListener('keydown', (e) => {
    // Escape → close mobile menu
    if (e.key === 'Escape') {
      const menu = document.getElementById('mobile-menu');
      if (menu && !menu.classList.contains('hidden')) {
        closeMobileMenu();
      }
    }

    // Konami Code detection — skip when typing in inputs
    const tag = (e.target as HTMLElement).tagName;
    if (tag === 'INPUT' || tag === 'TEXTAREA' || (e.target as HTMLElement).isContentEditable) return;

    // After sequence complete, check for Enter (permanent) or fire timed
    if (konamiComplete) {
      konamiComplete = false;
      clearTimeout(konamiCompleteTimer);
      if (e.key === 'Enter') {
        window.__triggerMatrixRain?.(true);
      } else {
        window.__triggerMatrixRain?.();
      }
      return;
    }

    clearTimeout(konamiTimer);
    konamiTimer = window.setTimeout(() => { konamiIndex = 0; }, 5000);

    if (e.key === KONAMI[konamiIndex]) {
      konamiIndex++;
      if (konamiIndex === KONAMI.length) {
        konamiIndex = 0;
        clearTimeout(konamiTimer);
        // Wait briefly for optional Enter key
        konamiComplete = true;
        konamiCompleteTimer = window.setTimeout(() => {
          if (konamiComplete) {
            konamiComplete = false;
            window.__triggerMatrixRain?.();
          }
        }, 800);
      }
    } else {
      konamiIndex = 0;
    }
  });

  // Close mobile menu on View Transition navigation
  document.addEventListener('astro:before-swap', () => {
    closeMobileMenu();
  });
</script>
